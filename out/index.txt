2:I[6743,["163","static/chunks/163-8520cca920ac972b.js","931","static/chunks/app/page-04b05724849aa768.js"],"default"]
7:I[2798,["185","static/chunks/app/layout-a43c37356bba19ce.js"],"ThemeProvider"]
8:I[4707,[],""]
9:I[6423,[],""]
3:Tea2,
Over the last few months, I‚Äôve been gradually building a **home server** that I actually *use* every day. What started as a simple experiment turned into a powerful, self-hosted environment running services I rely on‚Äîwithout depending on third-party clouds.

This blog walks through **why I built it, what I‚Äôm running, and how everything fits together**.

---

## Why I Built a Home Server

As a backend engineer, I wanted more than just a VPS:

- Full **control over infrastructure**
- A place to **experiment safely**
- No recurring cloud bills
- A deeper understanding of **networking, Linux, Docker, and automation**

Self-hosting forces you to confront real-world problems: DNS, SSL, backups, monitoring, and failure recovery. That‚Äôs exactly the learning I was looking for.

---

## Hardware Overview

I intentionally avoided racks and enterprise gear. My priorities were **low power, silent operation, and reliability**.

**Current setup:**
- Mini PC (x86)
- 16 GB RAM
- SSD for OS + containers
- HDD for backups and bulk storage
- Wired Ethernet (no Wi-Fi for the server)

This runs 24/7 without noticeable power or noise impact.

---

## Operating System & Base Setup

I‚Äôm running a **minimal Debian-based Linux distribution**.

Key choices:
- No desktop environment
- SSH-only access
- Firewall enabled
- Automatic security updates
- Custom SSH port + key-based login only

Keeping the OS minimal reduces attack surface and keeps maintenance simple.

---

## Containerization with Docker

Everything runs inside **Docker containers**, managed via Docker Compose.

Why Docker?
- Clean isolation
- Easy upgrades
- Reproducible setup
- Fast rollback if something breaks

Each service lives in its own compose file with persistent volumes mapped to disk.

---

## Services I‚Äôm Running

### 1. Reverse Proxy & SSL
All services are routed through a reverse proxy:
- Automatic HTTPS
- One public IP, many services
- Clean subdomain-based routing

### 2. Home Automation
I run a local home automation server to control:
- Lights
- Sensors
- Bluetooth/Zigbee devices

Everything works **locally**, even if the internet goes down.

### 3. Media & File Sharing
- Private file-sharing service
- Local media streaming
- LAN-first, cloud-optional access

### 4. Monitoring & Logs
- System metrics (CPU, memory, disk)
- Container health checks
- Logs centralized for debugging

If something breaks, I know *why*.

---

## Networking & Remote Access

My ISP doesn‚Äôt provide a static IP, so I use:
- Dynamic DNS
- Reverse tunneling for secure access
- No exposed services without authentication

Security always comes before convenience.

---

## Backups & Data Safety

One rule: **assume the disk will fail**.

My strategy:
- Nightly backups to a secondary drive
- Configuration files version-controlled
- Encrypted backups for sensitive data

Rebuilding the server from scratch takes under an hour.

---

## What I Learned

This setup taught me more than most cloud tutorials ever could:

- Linux internals
- Real networking (NAT, DNS, ports)
- Docker beyond ‚Äúhello world‚Äù
- Security tradeoffs
- How systems fail in practice

Most importantly, it gave me **confidence**. I know exactly what‚Äôs running, where my data lives, and how to fix things when they break.

---

## What‚Äôs Next

Planned upgrades:
- Local AI / LLM inference
- Custom voice assistant backend
- Smarter monitoring & alerting
- Power usage optimization

This server isn‚Äôt ‚Äúdone‚Äù‚Äîit‚Äôs a living system.

---

## Final Thoughts

A home server isn‚Äôt about replacing the cloud.  
It‚Äôs about **understanding it**.

If you‚Äôre a developer who enjoys building systems end-to-end, I highly recommend setting one up. Start small. Break things. Learn fast.
4:T43f,
# Distributed Task Processing

A highly scalable distributed task processing system built on Celery, capable of handling over 10,000 concurrent operations with robust fault tolerance and monitoring.

## Overview

Designed and implemented a production-grade distributed task queue system to handle high-volume background processing for web applications at scale.

## Key Features

- **10k+ Concurrent Operations**: Efficiently processes thousands of tasks simultaneously
- **Redis Clustering**: High-availability message broker with failover support
- **PostgreSQL Optimization**: Optimized database queries and connection pooling
- **Monitoring & Observability**: Comprehensive metrics and alerting

## Technical Architecture

The system leverages:
- **Celery** for distributed task execution
- **Redis** as the message broker and result backend
- **PostgreSQL** for persistent storage with advanced optimization
- **Python** for worker implementation

## Performance

Achieved 99.9% uptime with average task processing time under 100ms and automatic retry mechanisms for failed tasks.
5:T86c,
Here's a journey of how we build a smart web crawler before FireCrawl/etc existed.

## Story Time
---

(you may skip if you want)

Our task of building a smart web scrapper began when we tried to make a web srapper for web-archive/internet-archive. As you know, web archive is a corpus of massive snapshots of evey websites possible for the past 20 years.

Initial implementation used scrapy (python) package to write custom webscrappers...but this got tedious too soon. We (team of 2) started to look out for better solutions.

### Phase 1

**Enter, the AI based scrapper**. This is where it all began, we realised that we can parse HTML pages as it is, convert the content to markdown and with the help of LLMs it's quite easy to classify each section. Parsing HTML to md wasn't very difficult either. This worked great for the PoC.

But this didn't scaled well, because of the following reasons:

1. Markdown conversion was lossy, critical DOM structure, hierarchy, and semantic context are discarded during conversion.
2. Boilerplate content overwhelms signal, causing navigation, footers, and legal text to be misclassified as meaningful sections.
3. Section boundaries become ambiguous, forcing the LLM to guess structural intent from flattened text.
4. Images, pdfs and js-rendered content is often incomplete or missing, leading to inconsistent or partial extractions.
5. Token usage scales poorly, as markdown inflates content size and forces aggressive chunking.
6. Expensive AF!


### Phase 2

**RAG Approach** - 


## Key Features
---
- **98% Retrieval Precision**: Achieved industry-leading accuracy in document retrieval
- **Automated Content Optimization**: ML-powered content enhancement and SEO optimization
- **Scalable Architecture**: Handles millions of documents with sub-second query times
- **Vector Database Integration**: Efficient semantic search using state-of-the-art embeddings

## Technical Stack

Python, LangChain, Redis Queues (Yes, This exists), Qdrant (Open-source Vector DB)

## Impact

Deployed to production serving thousands of daily queries with consistent sub-second response times and 98% user satisfaction rate.
6:T117b,
# Making 3D Models Dance in Python

So I spent Summer 2022 teaching a scientific visualization library how to load modern 3D files and make them move. Turns out getting a virtual fox to do backflips involves a lot more math than you'd think.

## What's This All About?

FURY is this cool Python library that scientists use to visualize medical scans and research data. The problem? It couldn't load glTF files (the standard 3D format everyone uses these days) or animate anything. My mission was to fix that.

![Loading glTF models with textures](https://user-images.githubusercontent.com/74976752/174492510-b9f10816-3058-4a7b-a260-0627406354ba.png)

*Finally getting textures to work was oddly satisfying*

## The Journey: From "It Loads!" to "It Moves!"

First challenge: loaded a model, and the textures were upside down. Classic. Turns out glTF thinks (0,0) is at the top-left, but VTK (what FURY uses) wants it at the bottom-left. One coordinate flip later, we were in business.

### Simple Animations (The Easy Part)

So I thought, But it was far from easy. First of all, I had no clue how animations work behind the scene. So I went to the library, picked up the Computer Graphics book and applied a binary search on the content. I had a basic gist of how things work now. Also, huge thanks to [Mohamed](https://github.com/m-agour) for explaining the animation pipeline that he wrote. Got basic translation, rotation, and scaling working pretty quickly. Convert some binary data to NumPy arrays, hook up a timeline, boom! things move.

![Simple animations in action](https://user-images.githubusercontent.com/74976752/217645594-6054ea83-12e5-4868-b6a1-eee5a154bd26.gif)

*I was in love with these Spinning boxes*

### Morphing: When Cubes Get Weird

Morphing is basically vertex animation, you tell each vertex "hey, move over here a bit" and blend between poses. Implementing this meant wrestling with morph targets and weighted blending. But when it finally worked...

![Morphing animation demo](https://user-images.githubusercontent.com/74976752/217645485-153ec403-6c87-4282-8907-30d921106b34.gif)

*The AnimatedMorphCube doing its thing*

At this point, I would show any of these features to my friends, They will say "I'm a mad scientist", and I'm obsessed with cubes.

### Skeletal Animation: The Final Boss

This is where things got spicy. Skeletal animation means deforming a mesh based on bone movements. Sounds simple until you're debugging why the CesiumMan model looks like a pretzel.

The breakthrough came in week 13 when I figured out the hierarchical timeline system. Each bone gets its own timeline, and you have to respect parent-child relationships. The magic formula became:

```
SkinMatrix = InverseBindPose * BoneDeform
where BoneDeform = CurrentBoneTransform * ParentBoneTransform
```

![Skeletal animation working](https://user-images.githubusercontent.com/74976752/217645367-f901c6ed-ca20-40d6-92dd-f1cd8899ac7a.gif)

*When the bones finally cooperate*

The real celebration moment was getting multiple actors to work simultaneously. [Here's the BrainStem model demo](https://user-images.githubusercontent.com/74976752/193109340-2e37c255-139b-499f-a932-b8c0290bb481.mp4) showing multiple parts animating together.

## The Nerdy Details

Built with Python, OpenGL/VTK for rendering, and way too many hours staring at matrix multiplication order. Some fun challenges:

- **The Inverse Bind Matrix Mystery**: Took a while to understand it "undoes" the model's bind pose. Can't just multiply it with weights‚Äîlearned that the hard way.
- **Coordinate System Shenanigans**: glTF's top-left origin vs VTK's bottom-left origin
- **Parent Transforms**: Realizing parent transformations were already baked into the actor construction saved a ton of redundant calculations
- **Multiple Animations**: Making different parts animate at the same time without breaking everything

## What Got Merged

Shipped 5 major features and 5 smaller patches across 14 weeks:
- [Basic glTF import](https://github.com/fury-gl/fury/pull/600)
- [Scene export to glTF](https://github.com/fury-gl/fury/pull/630)
- [Model fetcher](https://github.com/fury-gl/fury/pull/602)
- [Simple animations](https://github.com/fury-gl/fury/pull/643)
- [Skeletal animation](https://github.com/fury-gl/fury/pull/685)
- [Morphing support](https://github.com/fury-gl/fury/pull/700)

PBR implementation is still pending, but it will be really cool to see some development on the PBR sides.
0:["PAEmJPZ6FMrIjRcFcMgr4",[[["",{"children":["__PAGE__",{}]},"$undefined","$undefined",true],["",{"children":["__PAGE__",{},[["$L1",["$","$L2",null,{"posts":[{"slug":"some-fancy-lights","title":"Extremely Fancy Lights (feat. WLED and HyperHDR)","excerpt":"Learning about self hosting, contol. access management and a computer networks","date":"May 2025","readTime":"5 min","tags":["Self Hosted","OSS","Linux","Debian","Docker","ESP"],"content":"\ntbd\n"},{"slug":"my-home-server-setup","title":"I Built a Home Server","excerpt":"Learning about self hosting, contol. access management and a computer networks","date":"Jan 2025","readTime":"8 min","tags":["Self Hosted","OSS","Linux","Debian","Docker","ESP"],"content":"$3"}],"projects":[{"slug":"distributed-task-processing","title":"Distributed Task Processing","description":"Scalable Celery-based task queue system handling 10k+ concurrent operations with Redis clustering and PostgreSQL optimization.","year":"2024","status":"Production","tech":["Python","Celery","Redis","PostgreSQL"],"content":"$4"},{"slug":"rag-content-system","title":"A smart web-scrapper?","description":"We built a smart (kinda) webscrapper with 98% recall accuracy on production.","year":"2024","status":"Edra Labs","tech":["Python","Vector DB","LangChain","FastAPI"],"content":"$5"},{"slug":"3d-renderer-enhancement","title":"glTF Integration for FURY","description":"Implemented comprehensive glTF 2.0 support for the FURY scientific visualization library including skeletal animations, morphing, and model import/export capabilities during Google Summer of Code 2022.","year":"2022","status":"Google Summer of Code","tech":["Python","OpenGL","glTF 2.0","VTK","Computer Graphics"],"content":"$6"}]}],null],null],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/portfolio/_next/static/css/825da5bfacb46671.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/portfolio/_next/static/css/052ec9a46fbb676a.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"en","className":"__variable_f07e2c","suppressHydrationWarning":true,"children":["$","body",null,{"className":"font-sans antialiased min-h-screen bg-background text-foreground","children":["$","$L7",null,{"attribute":"class","defaultTheme":"dark","enableSystem":false,"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]}]}]],null],null],["$La",null]]]]
a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"xtanion - Shivam Anand | Software Engineer"}],["$","meta","3",{"name":"description","content":"Software engineer specializing in backend systems, AI, and distributed architectures."}],["$","meta","4",{"name":"author","content":"xtanion"}],["$","meta","5",{"name":"author","content":"Shivam Anand"}],["$","meta","6",{"name":"generator","content":"Next.js"}],["$","meta","7",{"name":"keywords","content":"xtanion,Shivam Anand,software engineer,backend engineer,AI,distributed systems,full stack developer,Edra Labs,IIT Roorkee,IITR"}],["$","meta","8",{"name":"creator","content":"xtanion"}],["$","meta","9",{"name":"publisher","content":"xtanion"}],["$","meta","10",{"name":"robots","content":"index, follow"}],["$","meta","11",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","12",{"rel":"canonical","href":"https://xtanion.github.io/portfolio"}],["$","meta","13",{"property":"og:title","content":"xtanion - Shivam Anand | Software Engineer"}],["$","meta","14",{"property":"og:description","content":"Software engineer specializing in backend systems, AI/ML platforms, and distributed architectures."}],["$","meta","15",{"property":"og:url","content":"https://xtanion.github.io/portfolio"}],["$","meta","16",{"property":"og:site_name","content":"xtanion"}],["$","meta","17",{"property":"og:locale","content":"en_US"}],["$","meta","18",{"property":"og:type","content":"website"}],["$","meta","19",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","20",{"name":"twitter:creator","content":"@xtanion"}],["$","meta","21",{"name":"twitter:title","content":"xtanion - Shivam Anand | Software Engineer"}],["$","meta","22",{"name":"twitter:description","content":"Software engineer specializing in backend systems, AI/ML platforms, and distributed architectures."}],["$","link","23",{"rel":"icon","href":"data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üêß</text></svg>"}],["$","meta","24",{"name":"next-size-adjust"}]]
1:null
